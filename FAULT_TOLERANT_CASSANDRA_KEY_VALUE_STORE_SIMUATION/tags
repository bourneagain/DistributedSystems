!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Address	Member.cpp	/^Address::Address(const Address &anotherAddress) {$/;"	f	class:Address
Application	Application.cpp	/^Application::Application(char *infile) {$/;"	f	class:Application
ENcleanup	EmulNet.cpp	/^int EmulNet::ENcleanup() {$/;"	f	class:EmulNet
ENinit	EmulNet.cpp	/^void *EmulNet::ENinit(Address *myaddr, short port) {$/;"	f	class:EmulNet
ENrecv	EmulNet.cpp	/^int EmulNet::ENrecv(Address *myaddr, int (* enq)(void *, char *, int), struct timeval *t, int times, void *queue){$/;"	f	class:EmulNet
ENsend	EmulNet.cpp	/^int EmulNet::ENsend(Address *myaddr, Address *toaddr, char *data, int size) {$/;"	f	class:EmulNet
ENsend	EmulNet.cpp	/^int EmulNet::ENsend(Address *myaddr, Address *toaddr, string data) {$/;"	f	class:EmulNet
EmulNet	EmulNet.cpp	/^EmulNet::EmulNet(EmulNet &anotherEmulNet) {$/;"	f	class:EmulNet
EmulNet	EmulNet.cpp	/^EmulNet::EmulNet(Params *p)$/;"	f	class:EmulNet
Entry	Entry.cpp	/^Entry::Entry(string _value, int _timestamp, ReplicaType _replica){$/;"	f	class:Entry
Entry	Entry.cpp	/^Entry::Entry(string entry){$/;"	f	class:Entry
HashTable	HashTable.cpp	/^HashTable::HashTable() {}$/;"	f	class:HashTable
LOG	Log.cpp	/^void Log::LOG(Address *addr, const char * str, ...) {$/;"	f	class:Log
Log	Log.cpp	/^Log::Log(Params *p) {$/;"	f	class:Log
Log	Log.cpp	/^Log::Log(const Log &anotherLog) {$/;"	f	class:Log
MP1Node	MP1Node.cpp	/^MP1Node::MP1Node(Member *member, Params *params, EmulNet *emul, Log *log, Address *address) {$/;"	f	class:MP1Node
MP2Node	MP2Node.cpp	/^MP2Node::MP2Node(Member *memberNode, Params *par, EmulNet * emulNet, Log * log, Address * address) {$/;"	f	class:MP2Node
Member	Member.cpp	/^Member::Member(const Member &anotherMember) {$/;"	f	class:Member
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(const MemberListEntry &anotherMLE) {$/;"	f	class:MemberListEntry
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(int id, short port): id(id), port(port) {}$/;"	f	class:MemberListEntry
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(int id, short port, long heartbeat, long timestamp): id(id), port(port), heartbeat(heartbeat), timestamp(timestamp) {}$/;"	f	class:MemberListEntry
Message	Message.cpp	/^Message::Message(const Message& anotherMessage) {$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(int _transID, Address _fromAddr, MessageType _type, bool _success){$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(int _transID, Address _fromAddr, MessageType _type, string _key){$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(int _transID, Address _fromAddr, MessageType _type, string _key, string _value){$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(int _transID, Address _fromAddr, MessageType _type, string _key, string _value, ReplicaType _replica){$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(int _transID, Address _fromAddr, string _value){$/;"	f	class:Message
Message	Message.cpp	/^Message::Message(string message){$/;"	f	class:Message
Node	Node.cpp	/^Node::Node() {}$/;"	f	class:Node
Node	Node.cpp	/^Node::Node(Address address) {$/;"	f	class:Node
Node	Node.cpp	/^Node::Node(const Node& another) {$/;"	f	class:Node
Params	Params.cpp	/^Params::Params(): PORTNUM(8001) {}$/;"	f	class:Params
addEntryToMemberList	MP1Node.cpp	/^vector<MemberListEntry>::iterator MP1Node::addEntryToMemberList(int id, short port, long heartbeat) {$/;"	f	class:MP1Node
checkMessages	MP1Node.cpp	/^void MP1Node::checkMessages() {$/;"	f	class:MP1Node
checkMessages	MP2Node.cpp	/^void MP2Node::checkMessages() {$/;"	f	class:MP2Node
cleanMemberListTable	MP1Node.cpp	/^void MP1Node::cleanMemberListTable(Member *memberNode) {$/;"	f	class:MP1Node
clear	HashTable.cpp	/^void HashTable::clear() {$/;"	f	class:HashTable
clientCreate	MP2Node.cpp	/^void MP2Node::clientCreate(string key, string value) {$/;"	f	class:MP2Node
clientDelete	MP2Node.cpp	/^void MP2Node::clientDelete(string key){$/;"	f	class:MP2Node
clientRead	MP2Node.cpp	/^void MP2Node::clientRead(string key){$/;"	f	class:MP2Node
clientUpdate	MP2Node.cpp	/^void MP2Node::clientUpdate(string key, string value){$/;"	f	class:MP2Node
computeHashCode	Node.cpp	/^void Node::computeHashCode() {$/;"	f	class:Node
convertToString	Entry.cpp	/^string Entry::convertToString() {$/;"	f	class:Entry
count	HashTable.cpp	/^unsigned long HashTable::count(string key) {$/;"	f	class:HashTable
create	HashTable.cpp	/^bool HashTable::create(string key, string value) {$/;"	f	class:HashTable
createKeyValue	MP2Node.cpp	/^bool MP2Node::createKeyValue(string key, string value, ReplicaType replica) {$/;"	f	class:MP2Node
currentSize	HashTable.cpp	/^unsigned long HashTable::currentSize() {$/;"	f	class:HashTable
decodeToAddress	MP1Node.cpp	/^void MP1Node::decodeToAddress(Address *addr, int id, short port) {$/;"	f	class:MP1Node
deleteKey	HashTable.cpp	/^bool HashTable::deleteKey(string key) {$/;"	f	class:HashTable
deleteTest	Application.cpp	/^void Application::deleteTest() {$/;"	f	class:Application
deleteTimeOutNodes	MP1Node.cpp	/^void MP1Node::deleteTimeOutNodes() {$/;"	f	class:MP1Node
deletekey	MP2Node.cpp	/^bool MP2Node::deletekey(string key) {$/;"	f	class:MP2Node
deserializeAndUpdateTable	MP1Node.cpp	/^char* MP1Node::deserializeAndUpdateTable(const char *msg){$/;"	f	class:MP1Node
encode	MP1Node.cpp	/^char* MP1Node::encode(int id, short port, long heartbeat, long timestamp ) {$/;"	f	class:MP1Node
enqueueWrapper	MP1Node.cpp	/^int MP1Node::enqueueWrapper(void *env, char *buff, int size) {$/;"	f	class:MP1Node
enqueueWrapper	MP2Node.cpp	/^int MP2Node::enqueueWrapper(void *env, char *buff, int size) {$/;"	f	class:MP2Node
fail	Application.cpp	/^void Application::fail() {$/;"	f	class:Application
findARandomNodeThatIsAlive	Application.cpp	/^int Application::findARandomNodeThatIsAlive() {$/;"	f	class:Application
findNodes	MP2Node.cpp	/^vector<Node> MP2Node::findNodes(string key) {$/;"	f	class:MP2Node
finishUpThisNode	MP1Node.cpp	/^int MP1Node::finishUpThisNode(){$/;"	f	class:MP1Node
funcEntry	Trace.cpp	/^int Trace::funcEntry(char *funcName) {$/;"	f	class:Trace
funcExit	Trace.cpp	/^int Trace::funcExit(char *funcName, int f_rc) {$/;"	f	class:Trace
getAddress	Node.cpp	/^Address * Node::getAddress() {$/;"	f	class:Node
getHashCode	Node.cpp	/^size_t Node::getHashCode() {$/;"	f	class:Node
getJoinAddress	MP1Node.cpp	/^Address MP1Node::getJoinAddress() {$/;"	f	class:MP1Node
getMembershipList	MP2Node.cpp	/^vector<Node> MP2Node::getMembershipList() {$/;"	f	class:MP2Node
getTransactionID	MP2Node.cpp	/^int MP2Node::getTransactionID(){$/;"	f	class:MP2Node
getcurrtime	Params.cpp	/^int Params::getcurrtime(){$/;"	f	class:Params
getheartbeat	Member.cpp	/^long MemberListEntry::getheartbeat() {$/;"	f	class:MemberListEntry
getid	Member.cpp	/^int MemberListEntry::getid() {$/;"	f	class:MemberListEntry
getjoinaddr	Application.cpp	/^Address Application::getjoinaddr(void){$/;"	f	class:Application
getport	Member.cpp	/^short MemberListEntry::getport() {$/;"	f	class:MemberListEntry
gettimestamp	Member.cpp	/^long MemberListEntry::gettimestamp() {$/;"	f	class:MemberListEntry
handler	Application.cpp	/^void handler(int sig) {$/;"	f
hashFunction	MP2Node.cpp	/^size_t MP2Node::hashFunction(string key) {$/;"	f	class:MP2Node
incrTransactionID	MP2Node.cpp	/^void MP2Node::incrTransactionID(){$/;"	f	class:MP2Node
initMemberListTable	MP1Node.cpp	/^void MP1Node::initMemberListTable(Member *memberNode) {$/;"	f	class:MP1Node
initTestKVPairs	Application.cpp	/^void Application::initTestKVPairs() {$/;"	f	class:Application
initThisNode	MP1Node.cpp	/^int MP1Node::initThisNode(Address *joinaddr) {$/;"	f	class:MP1Node
insertTestKVPairs	Application.cpp	/^void Application::insertTestKVPairs() {$/;"	f	class:Application
introduceSelfToGroup	MP1Node.cpp	/^int MP1Node::introduceSelfToGroup(Address *joinaddr) {$/;"	f	class:MP1Node
isEmpty	HashTable.cpp	/^bool HashTable::isEmpty() {$/;"	f	class:HashTable
isNullAddress	MP1Node.cpp	/^int MP1Node::isNullAddress(Address *addr) {$/;"	f	class:MP1Node
logCreateFail	Log.cpp	/^void Log::logCreateFail(Address * address, bool isCoordinator, int transID, string key, string value){$/;"	f	class:Log
logCreateSuccess	Log.cpp	/^void Log::logCreateSuccess(Address * address, bool isCoordinator, int transID, string key, string value){$/;"	f	class:Log
logDeleteFail	Log.cpp	/^void Log::logDeleteFail(Address * address, bool isCoordinator, int transID, string key){$/;"	f	class:Log
logDeleteSuccess	Log.cpp	/^void Log::logDeleteSuccess(Address * address, bool isCoordinator, int transID, string key){$/;"	f	class:Log
logNodeAdd	Log.cpp	/^void Log::logNodeAdd(Address *thisNode, Address *addedAddr) {$/;"	f	class:Log
logNodeRemove	Log.cpp	/^void Log::logNodeRemove(Address *thisNode, Address *removedAddr) {$/;"	f	class:Log
logReadFail	Log.cpp	/^void Log::logReadFail(Address * address, bool isCoordinator, int transID, string key){$/;"	f	class:Log
logReadSuccess	Log.cpp	/^void Log::logReadSuccess(Address * address, bool isCoordinator, int transID, string key, string value){$/;"	f	class:Log
logUpdateFail	Log.cpp	/^void Log::logUpdateFail(Address * address, bool isCoordinator, int transID, string key, string newValue){$/;"	f	class:Log
logUpdateSuccess	Log.cpp	/^void Log::logUpdateSuccess(Address * address, bool isCoordinator, int transID, string key, string newValue){$/;"	f	class:Log
main	Application.cpp	/^int main(int argc, char *argv[]) {$/;"	f
mp1Run	Application.cpp	/^void Application::mp1Run() {$/;"	f	class:Application
mp2Run	Application.cpp	/^void Application::mp2Run() {$/;"	f	class:Application
nodeLoop	MP1Node.cpp	/^void MP1Node::nodeLoop() {$/;"	f	class:MP1Node
nodeLoopOps	MP1Node.cpp	/^void MP1Node::nodeLoopOps() {$/;"	f	class:MP1Node
nodeStart	MP1Node.cpp	/^void MP1Node::nodeStart(char *servaddrstr, short servport) {$/;"	f	class:MP1Node
operator <	Node.cpp	/^bool Node::operator < (const Node& another) const {$/;"	f	class:Node
operator =	EmulNet.cpp	/^EmulNet& EmulNet::operator =(EmulNet &anotherEmulNet) {$/;"	f	class:EmulNet
operator =	Log.cpp	/^Log& Log::operator = (const Log& anotherLog) {$/;"	f	class:Log
operator =	Member.cpp	/^Address& Address::operator =(const Address& anotherAddress) {$/;"	f	class:Address
operator =	Member.cpp	/^Member& Member::operator =(const Member& anotherMember) {$/;"	f	class:Member
operator =	Member.cpp	/^MemberListEntry& MemberListEntry::operator =(const MemberListEntry &anotherMLE) {$/;"	f	class:MemberListEntry
operator =	Message.cpp	/^Message& Message::operator =(const Message& anotherMessage) {$/;"	f	class:Message
operator =	Node.cpp	/^Node& Node::operator=(const Node& another) {$/;"	f	class:Node
operator ==	Member.cpp	/^bool Address::operator ==(const Address& anotherAddress) {$/;"	f	class:Address
printAddress	MP1Node.cpp	/^void MP1Node::printAddress(Address *addr)$/;"	f	class:MP1Node
printToTrace	Trace.cpp	/^int Trace::printToTrace(char *keyMsg, char *valueMsg) {$/;"	f	class:Trace
processJoinRep	MP1Node.cpp	/^void MP1Node::processJoinRep(void *env, char *data, int size) {$/;"	f	class:MP1Node
processJoinReq	MP1Node.cpp	/^void MP1Node::processJoinReq(void *env, char *data, int size) {$/;"	f	class:MP1Node
processUpdateRep	MP1Node.cpp	/^void MP1Node::processUpdateRep(void *env, char *data, int size) {$/;"	f	class:MP1Node
processUpdateReq	MP1Node.cpp	/^void MP1Node::processUpdateReq(void *env, char *data, int size) {$/;"	f	class:MP1Node
q_elt	Member.cpp	/^q_elt::q_elt(void *elt, int size): elt(elt), size(size) {}$/;"	f	class:q_elt
read	HashTable.cpp	/^string HashTable::read(string key) {$/;"	f	class:HashTable
readKey	MP2Node.cpp	/^string MP2Node::readKey(string key) {$/;"	f	class:MP2Node
readTest	Application.cpp	/^void Application::readTest() {$/;"	f	class:Application
recvCallBack	MP1Node.cpp	/^bool MP1Node::recvCallBack(void *env, char *data, int size ) {$/;"	f	class:MP1Node
recvLoop	MP1Node.cpp	/^int MP1Node::recvLoop() {$/;"	f	class:MP1Node
recvLoop	MP2Node.cpp	/^bool MP2Node::recvLoop() {$/;"	f	class:MP2Node
run	Application.cpp	/^int Application::run()$/;"	f	class:Application
searchList	MP1Node.cpp	/^vector<MemberListEntry>::iterator MP1Node::searchList(int id, short port) {$/;"	f	class:MP1Node
serialize	MP1Node.cpp	/^char* MP1Node::serialize(Member *node)$/;"	f	class:MP1Node
setAddress	Node.cpp	/^void Node::setAddress(Address address) {$/;"	f	class:Node
setHashCode	Node.cpp	/^void Node::setHashCode(size_t hashCode) {$/;"	f	class:Node
setheartbeat	Member.cpp	/^void MemberListEntry::setheartbeat(long hearbeat) {$/;"	f	class:MemberListEntry
setid	Member.cpp	/^void MemberListEntry::setid(int id) {$/;"	f	class:MemberListEntry
setparams	Params.cpp	/^void Params::setparams(char *config_file) {$/;"	f	class:Params
setport	Member.cpp	/^void MemberListEntry::setport(short port) {$/;"	f	class:MemberListEntry
settimestamp	Member.cpp	/^void MemberListEntry::settimestamp(long timestamp) {$/;"	f	class:MemberListEntry
stabilizationProtocol	MP2Node.cpp	/^void MP2Node::stabilizationProtocol() {$/;"	f	class:MP2Node
toString	Message.cpp	/^string Message::toString(){$/;"	f	class:Message
traceFileClose	Trace.cpp	/^int Trace::traceFileClose() {$/;"	f	class:Trace
traceFileCreate	Trace.cpp	/^int Trace::traceFileCreate() {$/;"	f	class:Trace
update	HashTable.cpp	/^bool HashTable::update(string key, string newValue) {$/;"	f	class:HashTable
updateKeyValue	MP2Node.cpp	/^bool MP2Node::updateKeyValue(string key, string value, ReplicaType replica) {$/;"	f	class:MP2Node
updateRing	MP2Node.cpp	/^void MP2Node::updateRing() {$/;"	f	class:MP2Node
updateTest	Application.cpp	/^void Application::updateTest() {$/;"	f	class:Application
~Application	Application.cpp	/^Application::~Application() {$/;"	f	class:Application
~EmulNet	EmulNet.cpp	/^EmulNet::~EmulNet() {}$/;"	f	class:EmulNet
~HashTable	HashTable.cpp	/^HashTable::~HashTable() {}$/;"	f	class:HashTable
~Log	Log.cpp	/^Log::~Log() {}$/;"	f	class:Log
~MP1Node	MP1Node.cpp	/^MP1Node::~MP1Node() {}$/;"	f	class:MP1Node
~MP2Node	MP2Node.cpp	/^MP2Node::~MP2Node() {$/;"	f	class:MP2Node
~Node	Node.cpp	/^Node::~Node() {}$/;"	f	class:Node
